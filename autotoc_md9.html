<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DryChem: Math</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DryChem
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">A collection of generic, templated libraries written in modern C++ with no dependencies</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('autotoc_md9.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Math </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The math library consists of a number of different functions and classes related to different fields in mathematics. The calculus module consists of functions and algorithms related to numerical differentiation and integration, while the statistics module contains functions and algorithms related to, you guessed it, statistics. There are also some standard library container wrappers and type traits for classifying containers according to the member functions and types it has. The following documentation describes the usage and motivation for the library.</p>
<ul>
<li><a href="#Getting-Started">Getting Started</a></li>
<li><a href="#Features">Features</a><ul>
<li><a href="#Calculus">Calculus</a></li>
<li><a href="#Containers">Containers</a></li>
<li><a href="#Statistics">Statistics</a></li>
<li><a href="#Math-Utilities">Math Utilities</a></li>
</ul>
</li>
<li><a href="#Usage">Usage</a></li>
</ul>
<p>All the functions and classes belonging to the math library are wrapped in the namespace <code><a class="el" href="namespace_dry_chem.html" title="Allow for a shorter namespace name for less using statements. ">DryChem</a></code>. Alternatively, these functions and classes also have their own nested namespace in the <code><a class="el" href="namespace_cpp_utils.html">CppUtils</a></code> namespace, which can be called as <code><a class="el" href="namespace_cpp_utils_1_1_math.html">CppUtils::Math</a></code>. While either can be used, <code><a class="el" href="namespace_dry_chem.html" title="Allow for a shorter namespace name for less using statements. ">DryChem</a></code> is preferred to provide a uniform interface for all portions of the library. The following line can be included in any user project to provide access to the math library:</p>
<div class="fragment"><div class="line">{C++}</div><div class="line">#include &lt;common-utils/math.hpp&gt;</div></div><!-- fragment --><ul>
<li><p class="startli"><a href="../../../include/common-utils/math/calculus/differentiation.hpp">Differentiation:</a></p>
<p class="startli">In the differentiation portion of the math library, three finite difference method (FDM) functions are provided for approximating the derivative of a given function. The methods implemented in this library are the forward difference method, the backwards difference method, and finally, the centered difference method. One thing to note when using either the forward or the backwards difference method is the output vector will have a size one less than the input container's sizes.</p>
<p class="startli">The centered difference method, which is effectively an average of the forward and backwards methods, will, by default, approximate the edge cases using the finite and backwards methods. These points will be less accurate than the middle elements of the returned vector, but serve to keep the size of the returned vector equal to those of the input containers. This can be turned off using the <code>correctBoundaries</code> flag.</p>
<p class="startli">All FDM methods take four iterators, two from the first container and two from the second container. The first two represent the independent variable in the function, while the second two iterators represent the dependent variable. Put another way, we are differentiating the second two iterators with respect to the first two. The iterator interface allows us to 1) use any conforming container range we want, and 2) differentiate over a range other than just the full container. While the templated interface of the functions may look intimidating, all template parameters can be correctly deduced by the compiler without any specifications from the end user. The interfaces were designed this way to accomodate the <code>PhysicalQuantity</code> type in the <a class="el" href="namespace_cpp_units.html">CppUnits</a> library without any change in how you would call the given function for a built-in type.</p>
<p class="startli">The <code><a class="el" href="namespace_cpp_utils_1_1_math.html#a65ee493ffcd5a7abb2f35724096d0748">centeredDifferenceMethod()</a></code> function was based loosely off NumPy's <code>gradient()</code> function, which you can read more about <a href="https://numpy.org/doc/stable/reference/generated/numpy.gradient.html">here</a>.</p>
</li>
<li><p class="startli"><a href="../../../include/common-utils/math/calculus/integration.hpp">Integration:</a></p>
<p class="startli">The integration portion of the math library consists of one main function template, <code><a class="el" href="namespace_cpp_utils_1_1_math.html#ac2910c7c6d24a95814d2aff8520c9710">cumulativeTrapzIntegration()</a></code>, and another helper function, <code><a class="el" href="namespace_cpp_utils_1_1_math.html#a3139a6bdb1903876b007071fb15bb1e5">trapz()</a></code>, that our main function calls.</p>
<p class="startli">The interface of the <code><a class="el" href="namespace_cpp_utils_1_1_math.html#ac2910c7c6d24a95814d2aff8520c9710">cumulativeTrapzIntegration()</a></code> function is nearly identical to those of the differentiation module, so consult that documentation for more information. Where the two methods differ is in the optional parameter: <code>initialValue</code>. By default, no value is specified for <code>initialValue</code>, and as such, the function returns a <code>std::vector&lt;&gt;</code> with one less element than the original container sizes. If a value is specified (note it should usually be a value of 0), this value becomes the first element of the returned container and all subsequent values depend on it. The returned container when an initial value is specified has the same size as the input containers.</p>
<p class="startli">This function was based loosely off SciPy's <code>cumtrapz()</code> function, which you can read more about <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.cumtrapz.html">here</a>. </p><hr/>
</li>
</ul>
<ul>
<li><p class="startli"><a href="../../../include/common-utils/math/containers/vector3D.hpp">Vector3D:</a></p>
<p class="startli">The <code>Vector3D&lt;&gt;</code> class template is a wrapper for a <code>std::array&lt;&gt;</code> with three elements, corresponding to the x, y, and z directions you would find in a mathematical/physical vector. For the most part, it behaves like a <code>std::array&lt;&gt;</code> and can even support structured-bindings through the tuple-like API. This class lends itself well to calculations involving the physical quantities, and will eventually get arithmetic operation support, likely using expression templates. </p><hr/>
</li>
</ul>
<ul>
<li><p class="startli"><a href="../../../include/common-utils/math/statistics/linearLeastSquaresFitting.hpp">Linear Least Squares Fitting:</a></p>
<p class="startli">The <code><a class="el" href="namespace_cpp_utils_1_1_math.html#ac9c7370c530bd8013aa5dfd10677cb11">linearLeastSquaresFitting()</a></code> function calculates the linear regression of some input function using the least squares method. Because this comes with a lot of information (slope, intercept, variance of the slope), a specialized structure defines its return type. This structure is an aggregate so it can be used with structured binding, which is the preferred way to return the output of this function.</p>
</li>
<li><p class="startli"><a href="../../../include/common-utils/math/statistics/statistics.hpp">General Statistical Functions:</a></p>
<p class="startli">For the statistical functions offered in the math library, there are two functions who's purpose is to help calculate the error in certain calculations. These functions, <code><a class="el" href="namespace_cpp_utils_1_1_math.html#ad644ab2a93244c016fc73a9b46203fe0">findOrderOfMagnitude()</a></code> and <code><a class="el" href="namespace_cpp_utils_1_1_math.html#a864f1b83a97d0af45d9454ee4c4acb7e">findAbsoluteError()</a></code> are esspecially useful when using the googletest function <code>ASSERT_NEAR()</code>. Here, the function expects an absolute error measurement and rather than calculate that for each value by hand, the <code><a class="el" href="namespace_cpp_utils_1_1_math.html#a864f1b83a97d0af45d9454ee4c4acb7e">findAbsoluteError()</a></code> function does it for you. We also have the <code><a class="el" href="namespace_cpp_utils_1_1_math.html#a28d4e1d9819d57114e773d010f267d51">calculateAverage()</a></code> and <code><a class="el" href="namespace_cpp_utils_1_1_math.html#a92a6bf6c7568468cbf00a94cf4517d37">calculateVariance()</a></code> functions which as their name suggests, calculates the average and variance of a container specified by the input iterators. </p><hr/>
</li>
</ul>
<ul>
<li><p class="startli"><a href="../../../include/common-utils/math/utils/basicMath.hpp">Basic Mathematical Functions:</a></p>
<p class="startli">By the way of basic math utilities, we have a couple helper functions that mainly can be used in <code>if</code> statements. <code>isEven</code> and <code>isOdd</code> both return a boolean if the passed integral type fits the classification of being even or odd, respectively. The <code>withinRange&lt;&gt;</code> function template performs some simple bounds checking and determines whether a given value is within a min and max value. All of these predicate functions can be used to simplify conditionals while giving the user a clean interface.</p>
<p class="startli">This part of the library also provides a little function to interpolate values along a given vector. By passing the <code>linearlyInterpolate&lt;&gt;()</code> function a <code>std::vector</code> to interpolate a long and the bounds of the interpolation, the function spits out a <code>std::vector</code> who's slope is linear from the lower to upper bound.</p>
</li>
<li><p class="startli"><a href="../../../include/common-utils/math/utils/mathExceptions.hpp">Error Handling:</a></p>
<p class="startli">All the major advanced mathematical functions (<code><a class="el" href="namespace_cpp_utils_1_1_math.html#ac9c7370c530bd8013aa5dfd10677cb11">linearLeastSquaresFitting()</a></code>, <code><a class="el" href="namespace_cpp_utils_1_1_math.html#a65ee493ffcd5a7abb2f35724096d0748">centeredDifferenceMethod()</a></code>, etc.) have the requirement that the sizes of the two containers we iterate over are the same. Since this would require a lot of repitition going through the <code>FatalException</code> interface, it was decided that a new, specialized exception type should be defined. This exception type, <code>InputSizeMismatch</code> derives from our <code>FatalException</code> class but controls the error message that is printed. Thus, all math functions that throw this exception will have the same basic message. The only difference between them is the file name and location of the error, a feature added with version 3.0 of the error library. </p><hr/>
</li>
</ul>
<p>For working examples of how to use the library, refer to the <a href="../tests">testing</a> and/or <a href="../samples">samples</a> directories, which together provide a comprehensive overview of the library's usage.</p>
<p>To build and run the code samples for the math library, one should include the <code>utils_build_samples=ON</code> option to the CMake instructions. Similarly, to build and run the unit tests for the individual math functions, one should include the <code>utils_build_tests=ON</code> option, as shown in the code below:</p>
<div class="fragment"><div class="line">cmake ../drychem/. -Dutils_build_samples=ON -Dutils_build_tests=ON</div><div class="line">make</div><div class="line"></div><div class="line">## Run the math library&#39;s samples ##</div><div class="line">cd bin/samples</div><div class="line">./finiteDifferencesExample</div><div class="line"></div><div class="line">## Run the math library&#39;s unit tests ##</div><div class="line">cd ../tests</div><div class="line">./testAllMathFunctions</div></div><!-- fragment --><p><em>NOTE: The samples and tests will not be installed with the rest of the library. They exist only to extend the documentation and help the user navigate the library.</em> </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Dec 8 2020 12:59:29 for DryChem by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
